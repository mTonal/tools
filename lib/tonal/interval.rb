class Tonal::Interval
  extend Forwardable
  include Comparable

  def_delegators :@intervalic_ratio, :to_r, :antecedent, :consequent, :to_cents

  attr_reader :lower_ratio, :upper_ratio, :intervalic_ratio

  INTERVAL_OF_EQUIVALENCE = 2/1r

  # @return [Tonal::Interval] the interval of the given ratios
  # @example
  #   Tonal::Interval.new(5) => 5/4 (5/4 / 1/1)
  # @example
  #   Tonal::Interval.new(3/2r, 5/4r) => 6/5 (3/2 / 5/4)
  # @example
  #   Tonal::Interval.new(3,2,4,3) => 9/8 (3/2 / 4/3)
  # @param args one argument representing a ratio, with 1/1r implied, or two arguments representing lower and upper ratios, or four arguments representing two numerator/denominator pairs for the lower and upper ratios
  # @param reduced boolean determining whether to use Tonal::ReducedRatio or Tonal::Ratio
  #
  def initialize(*args, reduced: true)
    raise(ArgumentError, "One, two or four arguments required. Either one ratio (the other defaulting to 1/1), two ratios, or two pairs of numerator, denominator", caller[0]) unless [1, 2, 4].include?(args.size)
    args = [args[0],1/1r] if args.length == 1
    klass = reduced ? Tonal::ReducedRatio : Tonal::Ratio
    @lower_ratio, @upper_ratio = case args.size
                                 when 2
                                   [klass.new(args[1].antecedent, args[1].consequent), klass.new(args[0].antecedent, args[0].consequent)]
                                 when 4
                                   [klass.new(args[2], args[3]), klass.new(args[0], args[1])]
                                 end
    @intervalic_ratio = @upper_ratio / @lower_ratio
  end
  alias :numerator :antecedent
  alias :denominator :consequent

  # @return [Array<Tonal::Ratio>] the upper and lower ratios as an array
  # @example
  #   interval = Tonal::Interval.new(3,2) => 3/2 (3/2 / 1/1)
  #   interval.to_a => [3/2, 1/1]
  #
  def to_a
    [upper_ratio, lower_ratio]
  end

  # @return [Array<Tonal::Ratio>] the ratios with common denominators
  # @example
  #   interval = Tonal::Interval.new(3,4) => 4/3 (4/3 / 1/1)
  #   interval.denominize => [3/2, 2/2]
  #
  def denominize
    ratios = to_a
    lcm = ratios.denominators.lcm
    ratios.map{|r| Tonal::Ratio.new(lcm / r.denominator * r.numerator, lcm)}
  end

  # @return [Tonal::Interval] the interval representing the root of self raised to a power
  # @example
  #   interval = Tonal::Interval.new(4/3r) => 4/3 (4/3 / 1/1)
  #   interval.root_interval(power: 1, root: 2) => 1.15 (1.15 / 1/1)
  # @param power [Integer] the power to which the root is raised
  # @param root [Integer] the root to be taken
  # @param approximant [Integer, nil] the index of the approximant to use
  # @param by_method [Symbol] the method to use for approximation (:continued_fraction or :tree_path)
  # @param from [Symbol] whether to return the interval calculated from the lower or upper ratio (:lower_ratio or :upper_ratio) of the interval
  #
  def root_interval(power: 1, root: 2, approximant: nil, by_method: :continued_fraction, from: :lower_ratio)
    root_ratio = intervalic_ratio.class.new(intervalic_ratio.to_r.power(power, root))
    resulting_ratio = approximant.nil? ? root_ratio : _approximate(root_ratio, by_method, approximant)
    _returning_interval(resulting_ratio, from:)
  end

  # @return [Tonal::Interval] the interval selected by the approximant key, from a set of approximations generated by the by_method algorithm
  # @example
  #   interval = Tonal::Interval.new(1.2) => 1.2 (1.2 / 1/1)
  #   interval.approximate => 6/5 (6/5 / 1/1)
  # @param approximant [Integer] the index of the approximant to use
  # @param by_method [Symbol] the method to use for approximation (:continued_fraction or :tree_path)
  # @param from [Symbol] whether to return the interval calculated from the lower or upper ratio (:lower_ratio or :upper_ratio) of the interval
  #
  def approximate(approximant=0, by_method: :continued_fraction, from: :lower_ratio)
    _returning_interval(_approximate(intervalic_ratio, by_method, approximant), from:)
  end

  # @return [String] a string representation of the interval
  # @example
  #   interval = Tonal::Interval.new(4,3) => 4/3 (4/3 / 1/1)
  #   interval.inspect => "4/3 (4/3 / 1/1)"
  #
  def inspect
    "#{intervalic_ratio.label} (#{upper_ratio.label} / #{lower_ratio.label})"
  end

  # @return [Integer] -1, 0, or 1 depending on whether this interval is less than, equal to, or greater than the other interval
  # @example
  #   interval1 = Tonal::Interval.new(4,3) => 4/3 (4/3 / 1/1)
  #   interval2 = Tonal::Interval.new(3,2) => 3/2 (3/2 / 1/1)
  #   interval1 <=> interval2 => -1
  #
  def <=>(rhs)
    intervalic_ratio.to_r <=> rhs.intervalic_ratio.to_r
  end

  private
  def _returning_interval(resulting_ratio, from:)
    from = [:lower_ratio, :upper_ratio].include?(from) ? from : :lower_ratio
    from == :lower_ratio ? Tonal::Interval.new(resulting_ratio, lower_ratio) : Tonal::Interval.new(upper_ratio, resulting_ratio)
  end

  def _approximate(ratio, by_method, approximant)
    by_method = [:continued_fraction, :tree_path].include?(by_method) ? "by_#{by_method}".to_sym : :by_continued_fraction
    ratio.approximate.send(by_method)[approximant]
  end
end
